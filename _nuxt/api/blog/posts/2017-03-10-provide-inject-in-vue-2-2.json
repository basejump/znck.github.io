{
  "id": "2017-03-10-provide-inject-in-vue-2-2",
  "filename": "blog/2017-03-10-provide-inject-in-vue-2-2.md",
  "attributes": {
    "date": "2017-03-10T00:00:00.000Z",
    "description": "Exploring provide & inject pair in Vue 2.2",
    "medium": "https://medium.com/@znck/provide-inject-in-vue-2-2-b6473a7f7816",
    "tags": [
      "vue",
      "javascript"
    ],
    "collection": "Vue",
    "title": "Provide/Inject in Vue 2.2",
    "updated_at": "2017-06-23T05:46:29.000Z",
    "collections": [
      "Vue"
    ]
  },
  "rendered": "<h1>Provide/Inject in Vue 2.2</h1>\n<p>The <strong>Initial D</strong> release of Vue have some amazing new features, including improved server side rendering, <code>v-model</code> customisations, better error handling, <code>provide</code> &amp; <code>inject</code> pair and many other small improvements.</p>\n<p>The <code>provide</code> and <code>inject</code> pair offers data flow deep in descendant chain. Ancestor components can serve as dependency injector for all its descendants, regardless how deep the component hierarchy is. The feature is advertised for advance plugin/component usages.</p>\n<h2>Workflow</h2>\n<p>It works in two parts — One component would <code>provide</code> data and other would use it (<code>inject</code>).</p>\n<blockquote>\n<p>The <code>provide</code> option should be an <code>object</code> or a <code>function</code> that returns an <code>object</code>. This <code>object</code> contains the properties that are available for injection into its descendants. You can use ES2015 Symbols as keys in this <code>object</code>, but only in environments that natively support <code>Symbol</code> and <code>Reflect.ownKeys</code>.</p>\n</blockquote>\n<pre><code class=\"language-js\"><span class=\"token keyword\">const</span> Provider <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  provide<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    foo<span class=\"token punctuation\">:</span> <span class=\"token string\">'bar'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p>The <code>inject</code> options should be either an <code>Array</code> of strings or an <code>object</code> where the keys stand for the local binding name, and the value being the key (<code>string</code> or <code>Symbol</code>) to search for in available injections.</p>\n</blockquote>\n<pre><code class=\"language-js\">  <span class=\"token keyword\">const</span> Child <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    inject<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<script async src=\"//jsfiddle.net/znck/4v95vfh3/embed/\"></script>\n<p>The <code>provide</code>/<code>inject</code> binding are <strong>NOT</strong> reactive. But if observed objects are provided, they do remain reactive.</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">const</span> Provider <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  provide <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">,</span> <span class=\"token string\">'bar'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n        enumerable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> foo <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  data<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> bar<span class=\"token punctuation\">:</span> <span class=\"token string\">'baz'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<script async src=\"//jsfiddle.net/znck/fdzwtz43/embed/\"></script>\n<p>Injections are available in <code>props</code> and <code>data</code>. So, you could set <code>prop</code> defaults to injected data or you can use injections as initial <code>data</code>.</p>\n<h2>Performance</h2>\n<p>Both <code>provide</code> and <code>inject</code> are one time actions performed at component initialisation. So, there won’t be any apparent performance degradation.</p>\n<p><code>provide</code> action is constant time.</p>\n<p>For each injected property, <code>inject</code> would traverse the parent chain until first provider is reached.</p>\n<h2>Conclusion</h2>\n<p>With <code>provide</code>/<code>inject</code>, you can provide data to distant descendent and that allows to create amazing functionalities. A whole new type of Vue plugins are about to appear.</p>\n<p>For example: A parent component can inject validation messages in input components.</p>\n<script async src=\"//jsfiddle.net/znck/go4yepc1/embed/\"></script>\n",
  "source": "---\ndate: 2017-03-10\ndescription: Exploring provide & inject pair in Vue 2.2\nmedium: https://medium.com/@znck/provide-inject-in-vue-2-2-b6473a7f7816\ntags:\n  - vue\n  - javascript\ncollection: Vue\n---\n# Provide/Inject in Vue 2.2\n\nThe **Initial D** release of Vue have some amazing new features, including improved server side rendering, `v-model` customisations, better error handling, `provide` & `inject` pair and many other small improvements.\n\nThe `provide` and `inject` pair offers data flow deep in descendant chain. Ancestor components can serve as dependency injector for all its descendants, regardless how deep the component hierarchy is. The feature is advertised for advance plugin/component usages. \n\n## Workflow\n\nIt works in two parts — One component would `provide` data and other would use it (`inject`).\n> The `provide` option should be an `object` or a `function` that returns an `object`. This `object` contains the properties that are available for injection into its descendants. You can use ES2015 Symbols as keys in this `object`, but only in environments that natively support `Symbol` and `Reflect.ownKeys`.\n  ``` js\n  const Provider = {\n    provide: {\n      foo: 'bar'\n    }\n  }\n  ```\n\n> The `inject` options should be either an `Array` of strings or an `object` where the keys stand for the local binding name, and the value being the key (`string` or `Symbol`) to search for in available injections.\n  ``` js\n    const Child = {\n      inject: ['foo']\n    }\n  ```\n\n<script async src=\"//jsfiddle.net/znck/4v95vfh3/embed/\"></script>\n\nThe `provide`/`inject` binding are **NOT** reactive. But if observed objects are provided, they do remain reactive.\n  ``` js\n  const Provider = {\n    provide () {\n      const foo = {}\n\n      Object.defineProperty(foo, 'bar', {\n          enumerable: true,\n          get: () => this.bar,\n      })\n\n      return { foo }\n    },\n\n    data: () => ({ bar: 'baz' })\n  }\n  ```\n\n<script async src=\"//jsfiddle.net/znck/fdzwtz43/embed/\"></script>\n\nInjections are available in `props` and `data`. So, you could set `prop` defaults to injected data or you can use injections as initial `data`.\n\n## Performance\n\nBoth `provide` and `inject` are one time actions performed at component initialisation. So, there won’t be any apparent performance degradation.\n\n`provide` action is constant time.\n\nFor each injected property, `inject` would traverse the parent chain until first provider is reached.\n\n## Conclusion\n\nWith `provide`/`inject`, you can provide data to distant descendent and that allows to create amazing functionalities. A whole new type of Vue plugins are about to appear.\n\nFor example: A parent component can inject validation messages in input components.\n\n<script async src=\"//jsfiddle.net/znck/go4yepc1/embed/\"></script>\n",
  "next": {
    "id": "2017-03-05-fiddle-with-vue-js",
    "attributes": {
      "date": "2017-03-05T00:00:00.000Z",
      "description": "A not so comprehensive guide on creating issue reproduction for Vue.js",
      "medium": "https://medium.com/@znck/fiddle-with-vue-js-dfd3e2924992",
      "tags": [
        "vue",
        "javascript"
      ],
      "collection": "Vue",
      "title": "Fiddle with Vue.js",
      "updated_at": "2017-06-20T14:20:48.000Z",
      "collections": [
        "Vue"
      ]
    }
  }
}